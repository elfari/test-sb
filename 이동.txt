/*=====================================================================
  FN_SIMILARITY_PCT  –  경량·고속 버전
  Oracle 19c 이상 (PRAGMA UDF 사용)  /  UTL_MATCH 권한 필요
=====================================================================*/
CREATE OR REPLACE FUNCTION fn_similarity_pct
(
    p_exist IN VARCHAR2,
    p_input IN VARCHAR2
) RETURN NUMBER
DETERMINISTIC
PRAGMA UDF                                -- ⟵ SQL 실행 시 컨텍스트 스위치 최소화
IS
    ------------------------------------------------------------------
    -- NULL → 0
    ------------------------------------------------------------------
    IF p_exist IS NULL OR p_input IS NULL THEN
        RETURN 0;
    END IF;

    ------------------------------------------------------------------
    -- 1.  전역 상수
    ------------------------------------------------------------------
    c_rx  CONSTANT VARCHAR2(100) := '[^[:alnum:]]';   -- 특수문자
    c_sp  CONSTANT VARCHAR2(1)   := ' ';

    ------------------------------------------------------------------
    -- 2.  로컬 변수 (모두 1 000 byte 한정)
    ------------------------------------------------------------------
    v_clean1   VARCHAR2(1000);
    v_clean2   VARCHAR2(1000);

    v_tokens1  SYS.ODCIVARCHAR2LIST := SYS.ODCIVARCHAR2LIST();
    v_tokens2  SYS.ODCIVARCHAR2LIST := SYS.ODCIVARCHAR2LIST();

    v_sorted1  VARCHAR2(1000);
    v_sorted2  VARCHAR2(1000);
    v_unsort1  VARCHAR2(1000);
    v_unsort2  VARCHAR2(1000);

    v_inter    PLS_INTEGER := 0;
    v_union    PLS_INTEGER := 0;
    v_jaccard  NUMBER      := 0;
    v_jaro     NUMBER;
    v_result   NUMBER;
BEGIN
    /*--------------------------------------------------------------
      3.  특수문자 제거·공백 통일   (정규식 1회씩만 호출)
    --------------------------------------------------------------*/
    v_clean1 := REGEXP_REPLACE( UPPER(p_exist), c_rx, c_sp );
    v_clean1 := REGEXP_REPLACE( v_clean1, '[,;]',  c_sp );
    v_clean1 := REGEXP_REPLACE( v_clean1, ' +',   c_sp );
    v_clean1 := TRIM(v_clean1);

    v_clean2 := REGEXP_REPLACE( UPPER(p_input), c_rx, c_sp );
    v_clean2 := REGEXP_REPLACE( v_clean2, '[,;]', c_sp );
    v_clean2 := REGEXP_REPLACE( v_clean2, ' +',  c_sp );
    v_clean2 := TRIM(v_clean2);

    /*--------------------------------------------------------------
      4.  토큰 분리 & 중복 제거  –  SQL 한 문으로 수행
        ⇒ EXECUTE IMMEDIATE 로 컨텍스트 스위치 1회만
    --------------------------------------------------------------*/
    EXECUTE IMMEDIATE '
        SELECT CAST(COLLECT(DISTINCT token ORDER BY token) AS SYS.ODCIVARCHAR2LIST),
               CAST(COLLECT(DISTINCT token)               AS SYS.ODCIVARCHAR2LIST)
        FROM (SELECT REGEXP_SUBSTR(:txt, ''[[:alnum:]]+'', 1, LEVEL) token
                FROM dual CONNECT BY REGEXP_SUBSTR(:txt, ''[[:alnum:]]+'', 1, LEVEL) IS NOT NULL)'
        INTO  v_tokens1, v_tokens2  USING v_clean1, v_clean1;

    -- v_tokens1 = 정렬, v_tokens2 = 원순서(중복 제거)

    EXECUTE IMMEDIATE '
        SELECT CAST(COLLECT(DISTINCT token ORDER BY token) AS SYS.ODCIVARCHAR2LIST),
               CAST(COLLECT(DISTINCT token)               AS SYS.ODCIVARCHAR2LIST)
        FROM (SELECT REGEXP_SUBSTR(:txt, ''[[:alnum:]]+'', 1, LEVEL) token
                FROM dual CONNECT BY REGEXP_SUBSTR(:txt, ''[[:alnum:]]+'', 1, LEVEL) IS NOT NULL)'
        INTO  v_tokens2(1), v_tokens2(2)  USING v_clean2, v_clean2;

    /*--------------------------------------------------------------
      5.  정렬 문자열 / 원순서 문자열
    --------------------------------------------------------------*/
    v_sorted1 := LISTAGG(v_tokens1,  ' ') WITHIN GROUP (ORDER BY ROWNUM);
    v_unsort1 := LISTAGG(v_tokens1(2), ' ') WITHIN GROUP (ORDER BY ROWNUM);

    v_sorted2 := LISTAGG(v_tokens2(1), ' ') WITHIN GROUP (ORDER BY ROWNUM);
    v_unsort2 := LISTAGG(v_tokens2(2), ' ') WITHIN GROUP (ORDER BY ROWNUM);

    /*--------------------------------------------------------------
      6.  99 / 100 규칙
    --------------------------------------------------------------*/
    IF v_sorted1 = v_sorted2 THEN
        IF v_unsort1 = v_unsort2 THEN
            v_result := 100;
        ELSE
            v_result :=  99;
        END IF;
    ELSE
        ----------------------------------------------------------------
        -- 7.  토큰 Jaccard  (정렬 리스트 사용)
        ----------------------------------------------------------------
        v_union := v_tokens1.COUNT + v_tokens2(1).COUNT;

        FOR i IN 1 .. v_tokens1.COUNT LOOP
            FOR j IN 1 .. v_tokens2(1).COUNT LOOP
                IF v_tokens1(i) = v_tokens2(1)(j) THEN
                    v_inter := v_inter + 1;
                    EXIT;
                END IF;
            END LOOP;
        END LOOP;

        v_union := v_union - v_inter;                     -- ∪ = Σ - ∩
        IF v_union > 0 THEN
            v_jaccard := ROUND(v_inter / v_union * 100, 2);
        END IF;

        ----------------------------------------------------------------
        -- 8.  문자열 Jaro-Winkler
        ----------------------------------------------------------------
        v_jaro := UTL_MATCH.JARO_WINKLER_SIMILARITY(
                      REPLACE(v_clean1, c_sp),
                      REPLACE(v_clean2, c_sp) );

        ----------------------------------------------------------------
        -- 9.  더 큰 값 사용
        ----------------------------------------------------------------
        v_result := GREATEST(v_jaccard, v_jaro);
    END IF;

    /*--------------------------------------------------------------
      10.  100 → 99 보정 (원문 다르면)
    --------------------------------------------------------------*/
    IF v_result = 100 AND
       TRIM(UPPER(p_exist)) <> TRIM(UPPER(p_input)) THEN
        v_result := 99;
    END IF;

    RETURN v_result;
END fn_similarity_pct;
/