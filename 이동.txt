/*=====================================================================
  FN_SIMILARITY_PCT
  ---------------------------------------------------------------------
  · NULL 인수                         → 0
  · 특수문자 제거                     : 영/한/중/숫자([:alnum:])만 유지
  · 토큰 분리                         : 공백·콤마(,)·세미콜론(;)
  · 중복 제거  →  오름차순 정렬  →  다시 문자열로 결합
  · 두 가지 유사도 계산
      ① 토큰 Jaccard (%)            ─ 교집합 ÷ 합집합
      ② 문자열 Jaro-Winkler (%)     ─ UTL_MATCH
    → 둘 중 큰 값 채택
  · 특별 규칙
      □ 토큰·순서 모두 같으면               ⇒ 100
      □ 토큰 집합만 같으면                 ⇒  99
      □ 최종 결과가 100 이지만
        p_exist ≠ p_input(대/소·공백·구분자 무시) ⇒  99
  ---------------------------------------------------------------------
  · 함수  : FN_SIMILARITY_PCT
  · 인수  : p_exist, p_input
  · Oracle 12c 이상 / UTL_MATCH 권한 필요
=====================================================================*/
CREATE OR REPLACE FUNCTION fn_similarity_pct
(
    p_exist IN VARCHAR2,
    p_input IN VARCHAR2
) RETURN NUMBER
DETERMINISTIC
IS
    /*---------------------- 0. NULL 처리 ----------------------*/
    IF p_exist IS NULL OR p_input IS NULL THEN
        RETURN 0;
    END IF;

    /*---------------------- 1. 지역 타입 ----------------------*/
    TYPE t_set  IS TABLE OF BOOLEAN       INDEX BY VARCHAR2(4000);
    TYPE t_list IS TABLE OF VARCHAR2(4000)INDEX BY PLS_INTEGER;

    /*---------------------- 2. 보조 : 리스트 정렬 --------------*/
    PROCEDURE sort_list(a IN OUT t_list) IS
        tmp VARCHAR2(4000);
    BEGIN
        FOR i IN 1 .. a.COUNT-1 LOOP
            FOR j IN i+1 .. a.COUNT LOOP
                IF a(i) > a(j) THEN
                    tmp := a(i); a(i) := a(j); a(j) := tmp;
                END IF;
            END LOOP;
        END LOOP;
    END;

    /*---------------------- 3. 보조 : 토큰화 -------------------*/
    PROCEDURE tokenize (
        p_src           IN  VARCHAR2,
        p_set           OUT t_set,
        p_list_orig     OUT t_list,     -- 중복 제거 + 원순서
        p_unsorted_str  OUT VARCHAR2,   -- 원순서(중복 제거) 문자열
        p_sorted_str    OUT VARCHAR2    -- 정렬 문자열
    ) IS
        clean   VARCHAR2(32767);
        tok     VARCHAR2(4000);
        idx     PLS_INTEGER := 0;
        list_s  t_list;
    BEGIN
        -- 특수문자 제거, 구분자(, ;) → 공백, 공백 압축
        clean := UPPER(p_src);
        clean := REGEXP_REPLACE(clean, '[^[:alnum:],; ]', ' ');
        clean := REGEXP_REPLACE(clean, '[,;]', ' ');
        clean := REGEXP_REPLACE(clean, ' +', ' ');
        clean := TRIM(clean);

        -- 토큰 추출 (중복 제거)
        FOR i IN 1 .. REGEXP_COUNT(clean, '[[:alnum:]]+') LOOP
            tok := REGEXP_SUBSTR(clean, '[[:alnum:]]+', 1, i);
            IF NOT p_set.EXISTS(tok) THEN
                p_set(tok) := TRUE;
                idx := idx + 1;
                p_list_orig(idx) := tok;
                list_s(idx)      := tok;
            END IF;
        END LOOP;

        -- 원순서 문자열
        FOR i IN 1 .. p_list_orig.COUNT LOOP
            p_unsorted_str := p_unsorted_str
                              || CASE WHEN i>1 THEN ' ' END
                              || p_list_orig(i);
        END LOOP;

        -- 정렬 문자열
        sort_list(list_s);
        FOR i IN 1 .. list_s.COUNT LOOP
            p_sorted_str := p_sorted_str
                            || CASE WHEN i>1 THEN ' ' END
                            || list_s(i);
        END LOOP;
    END;

    /*---------------------- 4. 변수 ---------------------------*/
    v_set1, v_set2            t_set;
    v_list1, v_list2          t_list;
    v_unsorted1 VARCHAR2(32767);
    v_unsorted2 VARCHAR2(32767);
    v_sorted1   VARCHAR2(32767);
    v_sorted2   VARCHAR2(32767);

    v_union_cnt  PLS_INTEGER := 0;
    v_inter_cnt  PLS_INTEGER := 0;
    v_tok        VARCHAR2(4000);

    v_jaccard    NUMBER := 0;
    v_jaro       NUMBER;
    v_result     NUMBER;
BEGIN
    /*---------------------- 5. 토큰화 -------------------------*/
    tokenize(p_exist, v_set1, v_list1, v_unsorted1, v_sorted1);
    tokenize(p_input, v_set2, v_list2, v_unsorted2, v_sorted2);

    /*---------------------- 6. 토큰 Jaccard -------------------*/
    v_tok := v_set1.FIRST;
    WHILE v_tok IS NOT NULL LOOP
        v_union_cnt := v_union_cnt + 1;
        IF v_set2.EXISTS(v_tok) THEN v_inter_cnt := v_inter_cnt + 1; END IF;
        v_tok := v_set1.NEXT(v_tok);
    END LOOP;

    v_tok := v_set2.FIRST;
    WHILE v_tok IS NOT NULL LOOP
        IF NOT v_set1.EXISTS(v_tok) THEN v_union_cnt := v_union_cnt + 1; END IF;
        v_tok := v_set2.NEXT(v_tok);
    END LOOP;

    IF v_union_cnt > 0 THEN
        v_jaccard := ROUND(v_inter_cnt / v_union_cnt * 100, 2);
    END IF;

    /*---------------------- 7. 문자열 Jaro-Winkler ------------*/
    v_jaro := UTL_MATCH.JARO_WINKLER_SIMILARITY(
                  REGEXP_REPLACE(UPPER(p_exist),'[^[:alnum:]]',''),
                  REGEXP_REPLACE(UPPER(p_input),'[^[:alnum:]]',''));

    /*---------------------- 8. 더 큰 값 선택 ------------------*/
    v_result := GREATEST(v_jaccard, v_jaro);

    /*---------------------- 9. 99 / 100 규칙 ------------------*/
    IF v_sorted1 = v_sorted2 THEN              -- 토큰 집합 동일
        IF v_unsorted1 = v_unsorted2 THEN      -- 순서까지 동일
            v_result := 100;
        ELSE
            v_result := 99;
        END IF;
    END IF;

    /* 10. 100 → 99 보정 : 두 원문이 실질적으로 다르면 */
    IF v_result = 100 AND
       TRIM(UPPER(p_exist)) <> TRIM(UPPER(p_input)) THEN
        v_result := 99;
    END IF;

    RETURN v_result;
END fn_similarity_pct;
/