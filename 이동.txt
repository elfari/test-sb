#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from __future__ import annotations
from pathlib import Path
import shutil
import sys
import tempfile

# ========= 설정(배열 3가지) =========
DIRECTORIES = [
    r"C:\path\to\dir1",
    # r"C:\path\to\dir2",
]

EXTENSIONS = [
    "txt", "md", "json",
    # "cfg", "ini", ...
]

# 따옴표/쌍따옴표 포함 가능. '정확히 같은 문자열'을 그대로 치환(정규식 아님)
REPLACEMENTS = [
    {"from": '"hello"', "to": "'hello'"},
    {"from": "OLD_VALUE", "to": "NEW_VALUE"},
]
# ==================================

# 안전 옵션
DRY_RUN = True           # True: 미리보기(파일 미변경), False: 실제 변경
MAKE_BACKUP = True       # True: 변경 전 <파일명>.bak 백업
BACKUP_EXT = ".bak"

UTF8 = "utf-8"           # 고정 인코딩
# ==================================

def should_process(file: Path, ext_set: set[str]) -> bool:
    if not file.is_file():
        return False
    if file.suffix.lower() == BACKUP_EXT.lower():
        return False
    ext = file.suffix[1:].lower() if file.suffix.startswith(".") else file.suffix.lower()
    return ext in ext_set

def read_text_utf8(p: Path) -> tuple[str, bytes]:
    """utf-8로만 읽기(엄격). 원본 바이트도 반환해서 줄바꿈 보존에 사용."""
    data = p.read_bytes()
    # 아주 단순한 바이너리 감지
    if b"\x00" in data:
        raise UnicodeDecodeError("binary-like", b"", 0, 1, "NUL in file")
    text = data.decode(UTF8)  # 실패 시 예외 발생
    return text, data

def write_text_preserving_newlines(p: Path, text: str, original_bytes: bytes) -> None:
    """원본의 줄바꿈 스타일(CRLF/LF) 보존해 utf-8로 원자적 쓰기."""
    # 줄바꿈 스타일 추정
    if b"\r\n" in original_bytes:
        nl = "\r\n"
        # 내부 표준화 후 CRLF로 변환
        text = text.replace("\r\n", "\n").replace("\n", "\r\n")
    else:
        nl = "\n"
        text = text.replace("\r\n", "\n")

    # 임시 파일에 먼저 기록(권한 최대한 보존)
    with tempfile.NamedTemporaryFile("w", delete=False, encoding=UTF8, newline="") as tmp:
        tmp.write(text)
        tmp_path = Path(tmp.name)

    try:
        shutil.copymode(p, tmp_path)
    except Exception:
        pass
    tmp_path.replace(p)

def apply_replacements(text: str) -> tuple[str, int]:
    total = 0
    new_text = text
    for rule in REPLACEMENTS:
        src = rule.get("from", "")
        dst = rule.get("to", "")
        if not isinstance(src, str) or not isinstance(dst, str):
            raise ValueError("REPLACEMENTS 항목은 {'from': str, 'to': str} 형태여야 합니다.")
        if src == "":
            continue
        cnt = new_text.count(src)
        if cnt:
            new_text = new_text.replace(src, dst)
            total += cnt
    return new_text, total

def process_file(p: Path) -> tuple[bool, int]:
    original_text, original_bytes = read_text_utf8(p)
    new_text, cnt = apply_replacements(original_text)
    if cnt == 0:
        return False, 0

    if DRY_RUN:
        return False, cnt

    if MAKE_BACKUP:
        backup = p.with_suffix(p.suffix + BACKUP_EXT)
        if not backup.exists():
            shutil.copy2(p, backup)

    write_text_preserving_newlines(p, new_text, original_bytes)
    return True, cnt

def main() -> int:
    if not DIRECTORIES:
        print("[오류] DIRECTORIES 비어 있음")
        return 2
    ext_set = {e.lower().lstrip(".") for e in EXTENSIONS if e}
    if not ext_set:
        print("[오류] EXTENSIONS 비어 있음")
        return 2
    if not REPLACEMENTS:
        print("[경고] REPLACEMENTS 비어 있음(변경 없음)")

    scanned = 0
    changed = 0
    total_cnt = 0

    for d in DIRECTORIES:
        base = Path(d)
        if not base.exists():
            print(f"[경고] 디렉토리 없음: {base}")
            continue

        for f in base.rglob("*"):
            if not should_process(f, ext_set):
                continue
            scanned += 1
            try:
                did_change, cnt = process_file(f)
                if cnt > 0:
                    action = "수정" if (did_change and not DRY_RUN) else "발견"
                    print(f"[{action}] {f} (+{cnt}회, utf-8)")
                    total_cnt += cnt
                    if did_change:
                        changed += 1
            except UnicodeDecodeError:
                # utf-8이 아닌 파일/바이너리로 보이는 파일은 건너뜀
                # 필요시 아래 주석 해제하여 로그
                # print(f"[건너뜀] utf-8 아님/바이너리: {f}")
                continue
            except Exception as e:
                print(f"[오류] {f}: {e}", file=sys.stderr)

    mode = "DRY-RUN" if DRY_RUN else "실제 변경"
    print(f"\n=== 완료 ({mode}) ===")
    print(f"- 스캔한 파일: {scanned}")
    print(f"- 총 치환 횟수: {total_cnt}")
    print(f"- 변경된 파일: {changed} (DRY-RUN이면 0)")
    return 0

if __name__ == "__main__":
    sys.exit(main())