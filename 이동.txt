private void copyRowsByIds(String owner, String table, String idCol, LinkedHashSet<String> ids) throws Exception {
    ArrayList<String> cols = listColumns(owner, table);
    if (!cols.contains(idCol)) {
        throw new IllegalArgumentException("idCol(" + idCol + ") not found in table columns");
    }

    // 컬럼 문자열 구성
    StringBuilder selCols = new StringBuilder();
    StringBuilder insCols = new StringBuilder();
    StringBuilder insQMarks = new StringBuilder();
    for (int i = 0; i < cols.size(); i++) {
        if (i > 0) { selCols.append(","); insCols.append(","); insQMarks.append(","); }
        selCols.append("\"").append(cols.get(i)).append("\"");
        insCols.append("\"").append(cols.get(i)).append("\"");
        insQMarks.append("?");
    }

    // UPDATE SET 절(키 컬럼 제외)
    StringBuilder updateSet = new StringBuilder();
    for (int i = 0, u = 0; i < cols.size(); i++) {
        String c = cols.get(i);
        if (c.equals(idCol)) continue;
        if (u++ > 0) updateSet.append(", ");
        updateSet.append("\"").append(c).append("\" = ?");
    }

    // MERGE 문 구성 (Oracle)
    // 파라미터 순서:
    //  1) USING 절의 키 1개
    //  2) UPDATE 절 값들 (키 제외 컬럼 순서대로)
    //  3) INSERT 절 값들 (모든 컬럼 순서대로)
    String mergeSql =
        "MERGE INTO \"" + owner + "\".\"" + table + "\" tgt\n" +
        "USING (SELECT ? AS \"" + idCol + "\" FROM dual) src\n" +
        "ON (tgt.\"" + idCol + "\" = src.\"" + idCol + "\")\n" +
        "WHEN MATCHED THEN UPDATE SET " + updateSet + "\n" +
        "WHEN NOT MATCHED THEN INSERT (" + insCols + ")\n" +
        "VALUES (" + insQMarks + ")";

    int total = 0;
    PreparedStatement psMerge = null;

    try {
        psMerge = tgtConn.prepareStatement(mergeSql);

        ArrayList<String> idList = new ArrayList<>(ids);
        ArrayList<ArrayList<String>> chunks = chunk(idList, 1000);

        for (int c = 0; c < chunks.size(); c++) {
            ArrayList<String> chunkIds = chunks.get(c);

            // 원본에서 대상 로우 선택
            StringBuilder ph = new StringBuilder();
            for (int i = 0; i < chunkIds.size(); i++) { if (i > 0) ph.append(","); ph.append("?"); }

            String select =
                "SELECT " + selCols +
                " FROM \"" + owner + "\".\"" + table + "\" WHERE \"" + idCol + "\" IN (" + ph + ")";
            String whereFrag = buildWhereFragment(true);
            if (whereFrag.length() > 0) select += whereFrag;

            PreparedStatement psSel = null;
            ResultSet rs = null;
            int batch = 0;

            try {
                psSel = srcConn.prepareStatement(select);
                int idx = 1;
                for (int i = 0; i < chunkIds.size(); i++) psSel.setString(idx++, chunkIds.get(i));
                rs = psSel.executeQuery();

                // 인덱스 헬퍼
                int colCount = cols.size();
                int idIndex = cols.indexOf(idCol); // 0-based(리스트), rs/getObject는 1-based

                while (rs.next()) {
                    // 1) 키 바인딩 (USING)
                    int p = 1;
                    Object idVal = rs.getObject(idIndex + 1);
                    psMerge.setObject(p++, idVal);

                    // 2) UPDATE 값들 (키 제외, cols 순서)
                    for (int i = 0; i < colCount; i++) {
                        if (i == idIndex) continue;
                        psMerge.setObject(p++, rs.getObject(i + 1));
                    }

                    // 3) INSERT 값들 (모든 컬럼)
                    for (int i = 0; i < colCount; i++) {
                        psMerge.setObject(p++, rs.getObject(i + 1));
                    }

                    psMerge.addBatch();
                    batch++;

                    if (batch % 500 == 0) {
                        int[] r = psMerge.executeBatch();
                        total += r.length;
                        batch = 0;
                    }
                }

                if (batch > 0) {
                    int[] r = psMerge.executeBatch();
                    total += r.length;
                }

            } finally {
                closeQuietly(rs);
                closeQuietly(psSel);
            }
        }
    } finally {
        closeQuietly(psMerge);
    }

    log("  ID 기준 업서트(UPDATE/INSERT) 건수: " + total);
}