------------------------------------------------------------------------------
--  자재명 유사도 함수  (Oracle 12c 이상)  
--  · 토큰 분리  : 공백 / 콤마(,) / 세미콜론(;)  
--  · 중복 제거  : O (대소문자 무시)  
--  · 유사도     : Jaccard ×100 (%)  
--    └ 토큰 집합 동일   → 99 %  
--    └ 집합·순서 모두 동일 → 100 %
------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION fn_material_similarity
(
    p_existing IN VARCHAR2,   -- 기존 자재명
    p_input    IN VARCHAR2    -- 신규 입력 자재명
) RETURN NUMBER
DETERMINISTIC
IS
    ------------------------------------------------------------------
    -- 지역 컬렉션 타입  
    ------------------------------------------------------------------
    TYPE t_set  IS TABLE OF BOOLEAN       INDEX BY VARCHAR2(4000); -- 집합
    TYPE t_list IS TABLE OF VARCHAR2(4000)INDEX BY PLS_INTEGER;    -- 순서
    ------------------------------------------------------------------
    -- 변수 선언
    ------------------------------------------------------------------
    v_set1   t_set;
    v_set2   t_set;
    v_list1  t_list;
    v_list2  t_list;
    v_cnt1   PLS_INTEGER;
    v_cnt2   PLS_INTEGER;

    v_union  PLS_INTEGER := 0;   -- |A∪B|
    v_inter  PLS_INTEGER := 0;   -- |A∩B|
    v_tok    VARCHAR2(4000);
    v_sim    NUMBER;

    v_set_eq   BOOLEAN := FALSE;
    v_order_eq BOOLEAN := FALSE;

    ------------------------------------------------------------------
    -- 문자열 → (중복 제거된) 토큰 집합·리스트 변환
    ------------------------------------------------------------------
    PROCEDURE tokenize (
        p_str   IN  VARCHAR2,
        p_list  OUT t_list,
        p_set   OUT t_set,
        p_cnt   OUT PLS_INTEGER
    ) IS
        v_word  VARCHAR2(4000);
        v_idx   PLS_INTEGER := 0;
    BEGIN
        FOR i IN 1 .. REGEXP_COUNT(p_str, '[^ ,;]+') LOOP
            v_word := UPPER(REGEXP_SUBSTR(p_str, '[^ ,;]+', 1, i));
            IF NOT p_set.EXISTS(v_word) THEN
                p_set(v_word) := TRUE;           -- 집합(중복 제거)
                v_idx         := v_idx + 1;
                p_list(v_idx) := v_word;         -- 최초 등장 순서
            END IF;
        END LOOP;
        p_cnt := v_idx;
    END tokenize;
BEGIN
    ----------------------- 1) 토큰화 -----------------------
    tokenize(p_existing, v_list1, v_set1, v_cnt1);
    tokenize(p_input   , v_list2, v_set2, v_cnt2);

    ----------------------- 2) 교집합·합집합 ----------------
    v_tok := v_set1.FIRST;
    WHILE v_tok IS NOT NULL LOOP
        v_union := v_union + 1;
        IF v_set2.EXISTS(v_tok) THEN
            v_inter := v_inter + 1;
        END IF;
        v_tok := v_set1.NEXT(v_tok);
    END LOOP;

    v_tok := v_set2.FIRST;
    WHILE v_tok IS NOT NULL LOOP
        IF NOT v_set1.EXISTS(v_tok) THEN
            v_union := v_union + 1;  -- set2 에만 있는 토큰
        END IF;
        v_tok := v_set2.NEXT(v_tok);
    END LOOP;

    IF v_union = 0 THEN            -- 양쪽 모두 빈 문자열
        v_sim := 100;
    ELSE
        v_sim := ROUND(v_inter / v_union * 100, 2);
    END IF;

    ----------------------- 3) 99 / 100 % 규칙 ---------------
    v_set_eq := (v_inter = v_union);  -- 토큰 집합 동일?

    IF v_set_eq AND v_cnt1 = v_cnt2 THEN
        v_order_eq := TRUE;
        FOR i IN 1 .. v_cnt1 LOOP
            IF v_list1(i) <> v_list2(i) THEN
                v_order_eq := FALSE;
                EXIT;
            END IF;
        END LOOP;
    END IF;

    IF v_set_eq THEN
        v_sim := CASE WHEN v_order_eq THEN 100 ELSE 99 END;
    END IF;

    RETURN v_sim;
END fn_material_similarity;
/