/* ---------------------------------------------------------------------------
   자재명 유사도 함수 : fn_material_similarity
   · 특수문자 제거 : 영문·한글·중문·숫자([[:alnum:]] = 모든 유니코드 문자&숫자) 이외는 공백으로 치환
   · 토큰 분리    : 공백(1개↑)                     ─ 공백·콤마·세미콜론 등은 이미 제거됨
   · 중복 제거    : O  (대소문자 무시 → UPPER)
   · 유사도(Jaccard ×100)  ─ 토큰집합 동일 99 %, 순서도 동일 100 %
---------------------------------------------------------------------------- */
CREATE OR REPLACE FUNCTION fn_material_similarity
(
    p_existing IN VARCHAR2,   -- 기존 자재명
    p_input    IN VARCHAR2    -- 신규(입력) 자재명
) RETURN NUMBER
DETERMINISTIC
IS
    /* -------- 지역 컬렉션 타입 -------- */
    TYPE t_set  IS TABLE OF BOOLEAN       INDEX BY VARCHAR2(4000); -- 집합
    TYPE t_list IS TABLE OF VARCHAR2(4000)INDEX BY PLS_INTEGER;    -- 순서

    /* -------- 변수 -------- */
    v_set1   t_set;   v_set2   t_set;
    v_list1  t_list;  v_list2  t_list;
    v_cnt1   PLS_INTEGER;   v_cnt2   PLS_INTEGER;
    v_union  PLS_INTEGER := 0;
    v_inter  PLS_INTEGER := 0;
    v_tok    VARCHAR2(4000);
    v_sim    NUMBER;
    v_set_eq   BOOLEAN := FALSE;
    v_order_eq BOOLEAN := FALSE;

    /* -------- 문자열  ▶  토큰집합·리스트 -------- */
    PROCEDURE tokenize (
        p_str   IN  VARCHAR2,
        p_list  OUT t_list,
        p_set   OUT t_set,
        p_cnt   OUT PLS_INTEGER
    ) IS
        v_clean VARCHAR2(32767);
        v_word  VARCHAR2(4000);
        v_idx   PLS_INTEGER := 0;
    BEGIN
        /* 1) 특수문자 제거 : 알파벳·한글·한자·숫자 외 → 공백 */
        v_clean := REGEXP_REPLACE(p_str,
                                  '[^[:alnum:]]',  -- [:alnum:] = 유니코드 글자·숫자
                                  ' ');
        /* 2) 토큰 추출 (연속 공백 무시) */
        FOR i IN 1 .. REGEXP_COUNT(v_clean, '[[:alnum:]]+') LOOP
            v_word := UPPER(REGEXP_SUBSTR(v_clean, '[[:alnum:]]+', 1, i));
            IF NOT p_set.EXISTS(v_word) THEN         -- 중복 제거
                p_set(v_word) := TRUE;
                v_idx         := v_idx + 1;
                p_list(v_idx) := v_word;             -- 최초 등장 순서 보존
            END IF;
        END LOOP;
        p_cnt := v_idx;
    END tokenize;
BEGIN
    /* 1) 토큰화 --------------------------------------------------------- */
    tokenize(p_existing, v_list1, v_set1, v_cnt1);
    tokenize(p_input   , v_list2, v_set2, v_cnt2);

    /* 2) |A∩B|, |A∪B| --------------------------------------------------- */
    v_tok := v_set1.FIRST;
    WHILE v_tok IS NOT NULL LOOP
        v_union := v_union + 1;
        IF v_set2.EXISTS(v_tok) THEN v_inter := v_inter + 1; END IF;
        v_tok := v_set1.NEXT(v_tok);
    END LOOP;

    v_tok := v_set2.FIRST;
    WHILE v_tok IS NOT NULL LOOP
        IF NOT v_set1.EXISTS(v_tok) THEN v_union := v_union + 1; END IF;
        v_tok := v_set2.NEXT(v_tok);
    END LOOP;

    IF v_union = 0 THEN          -- 둘 다 빈 문자열
        v_sim := 100;
    ELSE
        v_sim := ROUND(v_inter / v_union * 100, 2);
    END IF;

    /* 3) 99 % / 100 % 규칙 ---------------------------------------------- */
    v_set_eq := (v_inter = v_union);  -- 토큰 집합 동일?
    IF v_set_eq AND v_cnt1 = v_cnt2 THEN
        v_order_eq := TRUE;
        FOR i IN 1 .. v_cnt1 LOOP
            IF v_list1(i) <> v_list2(i) THEN
                v_order_eq := FALSE; EXIT;
            END IF;
        END LOOP;
    END IF;

    IF v_set_eq THEN
        v_sim := CASE WHEN v_order_eq THEN 100 ELSE 99 END;
    END IF;

    RETURN v_sim;
END fn_material_similarity;
/



-- ① 특수문자 포함·순서만 다름 → 99 %
SELECT fn_material_similarity(
         'ABC*(DEF)—GHI, JKL MN;OP',
         'MN OP,DEF;ABC GHI JKL ABC') AS sim_pct
FROM dual;   -- 99

-- ② 완전 동일(특수문자無) → 100 %
SELECT fn_material_similarity(
         'A1 한글 中文 XYZ',
         'A1 한글 中文 XYZ') AS sim_pct
FROM dual;   -- 100