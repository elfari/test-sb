WITH
/* [0] Input */
input_data AS (
    SELECT
        '5PART PIVOT CHAMFER;5MM-GE01-SD1-L0W6H26.13;' AS s1,
        'Centrifugal Pump;Flowrate : 2.5 ~ 8.5m_3h, Flowrate : 0.8 ~ 2.7m_3/h;.' AS s2
    FROM dual
),

/* [1] Normalize (upper + remove special chars -> space) */
prep AS (
    SELECT
        s1 AS org_s1,
        s2 AS org_s2,
        REGEXP_REPLACE(UPPER(s1), '[^A-Z0-9가-힣一-龥]', ' ') AS prep_s1,
        REGEXP_REPLACE(UPPER(s2), '[^A-Z0-9가-힣一-龥]', ' ') AS prep_s2
    FROM input_data
),

/* [2] Tokenize both strings (bounded by REGEXP_COUNT) */
tokens AS (
    SELECT
        'S1' AS typ,
        TRIM(REGEXP_SUBSTR(p.prep_s1, '[^ ]+', 1, lvl)) AS token
    FROM prep p
    CROSS JOIN (
        SELECT LEVEL AS lvl
        FROM dual
        CONNECT BY LEVEL <= REGEXP_COUNT((SELECT prep_s1 FROM prep), '[^ ]+')
    )
    UNION ALL
    SELECT
        'S2' AS typ,
        TRIM(REGEXP_SUBSTR(p.prep_s2, '[^ ]+', 1, lvl)) AS token
    FROM prep p
    CROSS JOIN (
        SELECT LEVEL AS lvl
        FROM dual
        CONNECT BY LEVEL <= REGEXP_COUNT((SELECT prep_s2 FROM prep), '[^ ]+')
    )
),

/* [3] Unique tokens -> sorted concat */
uniq AS (
    SELECT
        LISTAGG(DISTINCT CASE WHEN typ='S1' THEN token END, ' ')
            WITHIN GROUP (ORDER BY CASE WHEN typ='S1' THEN token END) AS uniq_s1,
        LISTAGG(DISTINCT CASE WHEN typ='S2' THEN token END, ' ')
            WITHIN GROUP (ORDER BY CASE WHEN typ='S2' THEN token END) AS uniq_s2
    FROM tokens
),

/* [4] Final compare strings (remove spaces) */
final_str AS (
    SELECT
        u.uniq_s1,
        u.uniq_s2,
        REPLACE(u.uniq_s1, ' ', '') AS fin_s1,
        REPLACE(u.uniq_s2, ' ', '') AS fin_s2
    FROM uniq u
),

/* [5] Character bag (counts) */
chars AS (
    SELECT 'S1' AS typ, SUBSTR(f.fin_s1, LEVEL, 1) AS ch
    FROM final_str f
    CONNECT BY LEVEL <= LENGTH(f.fin_s1)
           AND PRIOR SYS_GUID() IS NOT NULL
           AND PRIOR fin_s1 = fin_s1
    UNION ALL
    SELECT 'S2' AS typ, SUBSTR(f.fin_s2, LEVEL, 1) AS ch
    FROM final_str f
    CONNECT BY LEVEL <= LENGTH(f.fin_s2)
           AND PRIOR SYS_GUID() IS NOT NULL
           AND PRIOR fin_s2 = fin_s2
),

char_counts AS (
    SELECT
        ch,
        SUM(CASE WHEN typ='S1' THEN 1 ELSE 0 END) AS cnt1,
        SUM(CASE WHEN typ='S2' THEN 1 ELSE 0 END) AS cnt2
    FROM chars
    GROUP BY ch
),

calc AS (
    SELECT
        LENGTH(f.fin_s1) AS len1,
        LENGTH(f.fin_s2) AS len2,
        SUM(LEAST(c.cnt1, c.cnt2)) AS match_cnt,
        f.fin_s1,
        f.fin_s2,
        f.uniq_s1,
        f.uniq_s2
    FROM final_str f
    JOIN char_counts c ON 1=1
    GROUP BY
        f.fin_s1, f.fin_s2, f.uniq_s1, f.uniq_s2
)

/* [6] Output */
SELECT
    '1단계. 원본' AS 단계,
    (SELECT org_s1 FROM prep) AS 문자열1,
    (SELECT org_s2 FROM prep) AS 문자열2
FROM dual
UNION ALL
SELECT
    '2단계. 특수문자제거',
    (SELECT prep_s1 FROM prep),
    (SELECT prep_s2 FROM prep)
FROM dual
UNION ALL
SELECT
    '3단계. 중복단어제거',
    uniq_s1,
    uniq_s2
FROM calc
UNION ALL
SELECT
    '4단계. 공백제외 문자열',
    fin_s1,
    fin_s2
FROM calc
UNION ALL
SELECT
    '5단계. 공백제외 문자수',
    TO_CHAR(len1),
    TO_CHAR(len2)
FROM calc
UNION ALL
SELECT
    '6단계. 일치 문자수',
    TO_CHAR(match_cnt),
    TO_CHAR(match_cnt)
FROM calc
UNION ALL
SELECT
    '7단계. 최종 유사도(%)',
    TO_CHAR(ROUND((2 * match_cnt) / NULLIF(len1 + len2, 0) * 100, 2)) || '%',
    CASE
        WHEN (2 * match_cnt) / NULLIF(len1 + len2, 0) * 100 >= 100
             AND (SELECT org_s1 FROM prep) <> (SELECT org_s2 FROM prep)
        THEN '(보정 후: 99%)'
        ELSE '(보정 없음)'
    END
FROM calc;