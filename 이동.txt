CREATE OR REPLACE FUNCTION FN_SMART_SIMILARITY(
    str1 IN VARCHAR2,
    str2 IN VARCHAR2
) RETURN NUMBER
IS
    norm1 VARCHAR2(4000);
    norm2 VARCHAR2(4000);
    set1  VARCHAR2(4000) := '';
    set2  VARCHAR2(4000) := '';
    union_set VARCHAR2(4000) := '';
    inter_count INTEGER := 0;
    i INTEGER;
    c CHAR(1);
    jac_sim NUMBER;
    lev_sim NUMBER;
    len_max NUMBER;
    dist NUMBER;
    result NUMBER;
BEGIN
    -- 1. 정규화(소문자, 특수문자/공백 제거)
    norm1 := LOWER(REGEXP_REPLACE(str1, '[^A-Za-z0-9]', ''));
    norm2 := LOWER(REGEXP_REPLACE(str2, '[^A-Za-z0-9]', ''));

    -- 2. 문자 집합 생성(set1, set2)
    FOR i IN 1..LENGTH(norm1) LOOP
        c := SUBSTR(norm1, i, 1);
        IF INSTR(set1, c) = 0 THEN
            set1 := set1 || c;
        END IF;
    END LOOP;
    FOR i IN 1..LENGTH(norm2) LOOP
        c := SUBSTR(norm2, i, 1);
        IF INSTR(set2, c) = 0 THEN
            set2 := set2 || c;
        END IF;
    END LOOP;

    -- 3. 문자 집합 교집합, 합집합
    FOR i IN 1..LENGTH(set1) LOOP
        c := SUBSTR(set1, i, 1);
        IF INSTR(set2, c) > 0 THEN
            inter_count := inter_count + 1;
        END IF;
        IF INSTR(union_set, c) = 0 THEN
            union_set := union_set || c;
        END IF;
    END LOOP;
    FOR i IN 1..LENGTH(set2) LOOP
        c := SUBSTR(set2, i, 1);
        IF INSTR(union_set, c) = 0 THEN
            union_set := union_set || c;
        END IF;
    END LOOP;

    IF LENGTH(union_set) = 0 THEN
        jac_sim := 1; -- 둘 다 비어있으면 100% 유사
    ELSE
        jac_sim := inter_count / LENGTH(union_set); -- 0~1
    END IF;

    -- 4. Levenshtein(편집거리) 유사도
    len_max := GREATEST(LENGTH(norm1), LENGTH(norm2));
    IF len_max = 0 THEN
        lev_sim := 1;
    ELSE
        dist := UTL_MATCH.EDIT_DISTANCE(norm1, norm2);
        lev_sim := 1 - dist / len_max; -- 0~1
        IF lev_sim < 0 THEN
            lev_sim := 0;
        END IF;
    END IF;

    -- 5. 최종 유사도 (가중치: 집합 0.7, 순서 0.3)
    result := jac_sim * 0.7 + lev_sim * 0.3;

    RETURN ROUND(result * 100, 2); -- 퍼센트(0~100)
END;
/