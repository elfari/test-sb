/* -------------------------------------------------------------------------
   fn_material_similarity  (Oracle 12c 이상)
   --------------------------------------------------------------------------
   • NULL 처리  : 기존값 또는 입력값이 NULL → 0  (즉시 반환)
   • 특수문자 제거 : 영·한·중·숫자만 유지
   • 토큰화      : 공백·콤마·세미콜론
   • 중복 제거·정렬·대소문자 무시
   • 100 / 99 % 규칙
   • 그 외 →  MAX(토큰 Jaccard, 문자열 Jaro-Winkler)
   ----------------------------------------------------------------------- */
CREATE OR REPLACE FUNCTION fn_material_similarity
(
    p_existing IN VARCHAR2,
    p_input    IN VARCHAR2
) RETURN NUMBER
DETERMINISTIC
IS
    /* ─────────── EARLY EXIT : NULL ─────────── */
    -- NULL ≡ 유사도 0
    -- 빈 문자열('') 은 “내용 없음” 으로 간주하려면 아래 조건에 OR TRIM(...)='' 추가
    -- (요구사항은 “NULL” 만 0 처리이므로 그대로 둠)
    IF p_existing IS NULL OR p_input IS NULL THEN
        RETURN 0;
    END IF;

    /* ─────────── 지역 타입 ─────────── */
    TYPE t_set   IS TABLE OF BOOLEAN       INDEX BY VARCHAR2(4000);
    TYPE t_list  IS TABLE OF VARCHAR2(4000)INDEX BY PLS_INTEGER;

    /* ─────────── 유틸 : 리스트 정렬 ─────────── */
    PROCEDURE sort_list(p_list IN OUT t_list) IS
        tmp VARCHAR2(4000);
    BEGIN
        IF p_list.COUNT <= 1 THEN RETURN; END IF;
        FOR i IN 1 .. p_list.COUNT-1 LOOP
            FOR j IN i+1 .. p_list.COUNT LOOP
                IF p_list(i) > p_list(j) THEN
                    tmp        := p_list(i);
                    p_list(i)  := p_list(j);
                    p_list(j)  := tmp;
                END IF;
            END LOOP;
        END LOOP;
    END;

    /* ─────────── 유틸 : 토큰화 ─────────── */
    PROCEDURE tokenize (
        p_str        IN  VARCHAR2,
        p_set        OUT t_set,
        p_list_orig  OUT t_list,
        p_sorted_str OUT VARCHAR2
    ) IS
        v_clean VARCHAR2(32767);
        v_word  VARCHAR2(4000);
        v_idx   PLS_INTEGER := 0;
        v_list_sorted t_list;
    BEGIN
        v_clean := REGEXP_REPLACE(UPPER(p_str), '[^[:alnum:],; ]', ' ');
        v_clean := REGEXP_REPLACE(v_clean, '[,;]', ' ');
        v_clean := REGEXP_REPLACE(v_clean, ' +', ' ');
        v_clean := TRIM(v_clean);

        FOR i IN 1 .. REGEXP_COUNT(v_clean, '[[:alnum:]]+') LOOP
            v_word := REGEXP_SUBSTR(v_clean, '[[:alnum:]]+', 1, i);
            IF NOT p_set.EXISTS(v_word) THEN
                p_set(v_word) := TRUE;
                v_idx         := v_idx + 1;
                p_list_orig(v_idx) := v_word;
                v_list_sorted(v_idx) := v_word;
            END IF;
        END LOOP;

        sort_list(v_list_sorted);
        FOR i IN 1 .. v_list_sorted.COUNT LOOP
            p_sorted_str := p_sorted_str || CASE WHEN i>1 THEN ' ' END
                                              || v_list_sorted(i);
        END LOOP;
    END;

    /* ─────────── 변수 선언 ─────────── */
    v_set1, v_set2        t_set;
    v_list1, v_list2      t_list;
    v_sorted1 VARCHAR2(32767);
    v_sorted2 VARCHAR2(32767);
    v_union  PLS_INTEGER := 0;
    v_inter  PLS_INTEGER := 0;
    v_tok    VARCHAR2(4000);
    v_order_eq BOOLEAN := FALSE;
    v_set_eq   BOOLEAN := FALSE;
    v_jaccard  NUMBER  := 0;
    v_string   NUMBER;
BEGIN
    /* 1) 토큰화 --------------------------------------------------------- */
    tokenize(p_existing, v_set1, v_list1, v_sorted1);
    tokenize(p_input   , v_set2, v_list2, v_sorted2);

    /* 2) 100 / 99 % 규칙 ------------------------------------------------ */
    IF v_list1.COUNT = v_list2.COUNT THEN
        v_order_eq := TRUE;
        FOR i IN 1 .. v_list1.COUNT LOOP
            IF v_list1(i) <> v_list2(i) THEN
                v_order_eq := FALSE; EXIT;
            END IF;
        END LOOP;
    END IF;

    IF v_set1.COUNT = v_set2.COUNT THEN
        v_set_eq := TRUE;
        v_tok := v_set1.FIRST;
        WHILE v_tok IS NOT NULL LOOP
            IF NOT v_set2.EXISTS(v_tok) THEN v_set_eq := FALSE; EXIT; END IF;
            v_tok := v_set1.NEXT(v_tok);
        END LOOP;
    END IF;

    IF v_order_eq THEN RETURN 100; END IF;
    IF v_set_eq   THEN RETURN  99; END IF;

    /* 3) 토큰 Jaccard ---------------------------------------------------- */
    v_tok := v_set1.FIRST;
    WHILE v_tok IS NOT NULL LOOP
        v_union := v_union + 1;
        IF v_set2.EXISTS(v_tok) THEN v_inter := v_inter + 1; END IF;
        v_tok := v_set1.NEXT(v_tok);
    END LOOP;

    v_tok := v_set2.FIRST;
    WHILE v_tok IS NOT NULL LOOP
        IF NOT v_set1.EXISTS(v_tok) THEN v_union := v_union + 1; END IF;
        v_tok := v_set2.NEXT(v_tok);
    END LOOP;

    IF v_union > 0 THEN
        v_jaccard := ROUND(v_inter / v_union * 100, 2);
    END IF;

    /* 4) 문자열 Jaro-Winkler -------------------------------------------- */
    v_string := UTL_MATCH.JARO_WINKLER_SIMILARITY(
                    REGEXP_REPLACE(UPPER(p_existing),'[^[:alnum:]]',''),
                    REGEXP_REPLACE(UPPER(p_input)   ,'[^[:alnum:]]',''));

    /* 5) 최종 : 둘 중 큰 값 --------------------------------------------- */
    RETURN GREATEST(v_jaccard, v_string);
END fn_material_similarity;
/