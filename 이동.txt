CREATE OR REPLACE FUNCTION FN_SIMILARITY_PCT (
    p_exist IN VARCHAR2,
    p_input IN VARCHAR2
) RETURN NUMBER IS

    /* 변수 선언부 */
    v_exist_clean   VARCHAR2(4000);
    v_input_clean   VARCHAR2(4000);
    v_exist_final   VARCHAR2(4000);
    v_input_final   VARCHAR2(4000);
    v_similarity    NUMBER := 0;

BEGIN
    /* 기존값 또는 입력값이 NULL이면 0 처리 */
    IF p_exist IS NULL OR p_input IS NULL THEN
        v_similarity := 0;
    ELSE
        /* 기존값 정제: 영문, 숫자, 한글, 중문을 제외한 모든 문자를 공백으로 치환 */
        v_exist_clean := REGEXP_REPLACE(UPPER(p_exist), '[^A-Z0-9가-힣' || UNISTR('\4E00-\9FFF') || ']', ' ');
        v_input_clean := REGEXP_REPLACE(UPPER(p_input), '[^A-Z0-9가-힣' || UNISTR('\4E00-\9FFF') || ']', ' ');

        /* 기존값 토큰화: 길이순 정렬 후 병합 */
        SELECT LISTAGG(token, '') WITHIN GROUP (ORDER BY LENGTH(token) DESC, token)
          INTO v_exist_final
          FROM (
              SELECT DISTINCT REGEXP_SUBSTR(v_exist_clean, '[^ ]+', 1, LEVEL) AS token
                FROM DUAL
              CONNECT BY REGEXP_SUBSTR(v_exist_clean, '[^ ]+', 1, LEVEL) IS NOT NULL
          );

        /* 입력값 토큰화: 길이순 정렬 후 병합 */
        SELECT LISTAGG(token, '') WITHIN GROUP (ORDER BY LENGTH(token) DESC, token)
          INTO v_input_final
          FROM (
              SELECT DISTINCT REGEXP_SUBSTR(v_input_clean, '[^ ]+', 1, LEVEL) AS token
                FROM DUAL
              CONNECT BY REGEXP_SUBSTR(v_input_clean, '[^ ]+', 1, LEVEL) IS NOT NULL
          );

        /* 유사도 계산 로직 */
        IF v_exist_final = v_input_final THEN
            IF p_exist = p_input THEN
                v_similarity := 100;
            ELSE
                v_similarity := 99;
            END IF;
        ELSE
            /* [수정됨] Jaro-Winkler 대신 Edit Distance 사용 */
            /* 전혀 다른 단어들의 조합일 때 점수를 확실하게 낮추기 위함 */
            v_similarity := UTL_MATCH.EDIT_DISTANCE_SIMILARITY(v_exist_final, v_input_final);
        END IF;

    END IF;

    RETURN v_similarity;

EXCEPTION
    WHEN OTHERS THEN
        RETURN 0;
END FN_SIMILARITY_PCT;
/


