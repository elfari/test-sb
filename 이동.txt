CREATE OR REPLACE FUNCTION FN_SIMILARITY_PCT(
    p_exist IN VARCHAR2,
    p_input IN VARCHAR2
) RETURN NUMBER
IS
    -- 결과 유사도(%)를 저장할 변수
    v_similarity NUMBER := 0;

    -- 전처리 후 토큰을 합친 문자열
    v_exist_str VARCHAR2(4000);
    v_input_str VARCHAR2(4000);

    -- 전처리 및 토큰 분할을 위한 임시 변수
    v_exist_raw VARCHAR2(4000);
    v_input_raw VARCHAR2(4000);

    -- 최종 비교용 문자열
    v_exist_sorted VARCHAR2(4000);
    v_input_sorted VARCHAR2(4000);

    -- 문자열이 아예 같은지 여부
    v_exact_same BOOLEAN := FALSE;

    -- 문자열이 정렬 전 기준으로 같은지 여부
    v_orderless_same BOOLEAN := FALSE;

    -- 토큰 임시 저장용 테이블 타입
    TYPE t_token_tbl IS TABLE OF VARCHAR2(4000) INDEX BY PLS_INTEGER;
    v_exist_tokens t_token_tbl;
    v_input_tokens t_token_tbl;

    -- 중복 제거된 토큰 저장용 set
    v_exist_set t_token_tbl;
    v_input_set t_token_tbl;

    -- 정렬에 쓸 토큰 목록
    v_exist_sorted_list t_token_tbl;
    v_input_sorted_list t_token_tbl;

    -- 기타 변수
    v_token VARCHAR2(4000);
    v_idx PLS_INTEGER;
    v_cnt PLS_INTEGER;

    -- 구분자 기준 패턴
    c_delims CONSTANT VARCHAR2(10) := '[ ,;]';
BEGIN
    -- NULL 입력 체크
    IF p_exist IS NULL OR p_input IS NULL THEN
        RETURN 0;
    END IF;

    -- 1. 특수문자 제거, 대소문자 통일
    v_exist_raw := LOWER(REGEXP_REPLACE(p_exist, '[^A-Za-z0-9가-힣ㄱ-ㅎㅏ-ㅣ一-龥]+', ' '));
    v_input_raw := LOWER(REGEXP_REPLACE(p_input, '[^A-Za-z0-9가-힣ㄱ-ㅎㅏ-ㅣ一-龥]+', ' '));

    -- 2. 공백, 콤마, 세미콜론으로 토큰 분리 및 중복제거
    v_idx := 1;
    v_cnt := 0;
    FOR token IN (SELECT DISTINCT REGEXP_SUBSTR(v_exist_raw, '[^ ,;]+', 1, LEVEL) AS token
                    FROM dual
                  CONNECT BY REGEXP_SUBSTR(v_exist_raw, '[^ ,;]+', 1, LEVEL) IS NOT NULL)
    LOOP
        v_exist_set(v_idx) := token.token;
        v_idx := v_idx + 1;
    END LOOP;

    v_cnt := v_idx - 1;

    -- 토큰을 하나의 문자열로 합침 (정렬 전)
    v_exist_str := '';
    FOR i IN 1 .. v_cnt LOOP
        v_exist_str := v_exist_str || v_exist_set(i);
    END LOOP;

    -- 정렬을 위해 토큰 배열에 담기
    v_exist_sorted_list := v_exist_set;

    -- 토큰 정렬 (버블정렬 대체로 SELECT .. ORDER BY 사용)
    v_exist_sorted := '';
    FOR token IN (SELECT COLUMN_VALUE FROM TABLE(CAST(COLLECT(v_exist_set(i)) AS SYS.ODCIVARCHAR2LIST)) t
                  ORDER BY COLUMN_VALUE)
    LOOP
        v_exist_sorted := v_exist_sorted || token.COLUMN_VALUE;
    END LOOP;

    -- 입력값 동일하게 처리
    v_idx := 1;
    v_cnt := 0;
    FOR token IN (SELECT DISTINCT REGEXP_SUBSTR(v_input_raw, '[^ ,;]+', 1, LEVEL) AS token
                    FROM dual
                  CONNECT BY REGEXP_SUBSTR(v_input_raw, '[^ ,;]+', 1, LEVEL) IS NOT NULL)
    LOOP
        v_input_set(v_idx) := token.token;
        v_idx := v_idx + 1;
    END LOOP;

    v_cnt := v_idx - 1;
    v_input_str := '';
    FOR i IN 1 .. v_cnt LOOP
        v_input_str := v_input_str || v_input_set(i);
    END LOOP;

    v_input_sorted_list := v_input_set;
    v_input_sorted := '';
    FOR token IN (SELECT COLUMN_VALUE FROM TABLE(CAST(COLLECT(v_input_set(i)) AS SYS.ODCIVARCHAR2LIST)) t
                  ORDER BY COLUMN_VALUE)
    LOOP
        v_input_sorted := v_input_sorted || token.COLUMN_VALUE;
    END LOOP;

    -- 3. 문자열 동일성/정렬여부 체크
    IF v_exist_str = v_input_str THEN
        v_orderless_same := TRUE;
    END IF;

    IF v_exist_sorted = v_input_sorted THEN
        v_exact_same := TRUE;
    END IF;

    -- 4. 유사도 계산
    IF v_exact_same THEN
        IF v_exist_str = v_input_str THEN
            v_similarity := 100;
        ELSE
            v_similarity := 99;
        END IF;
    ELSIF v_orderless_same THEN
        v_similarity := 99;
    ELSE
        v_similarity := 0;
    END IF;

    RETURN v_similarity;
END FN_SIMILARITY_PCT;
/